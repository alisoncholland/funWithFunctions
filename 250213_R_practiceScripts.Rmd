---
title: "practiceForMia"
author: "Alison C. Holland"
date: "2024-09"
output: html_document
---

Download and load libraries
---------------------------
```{r}
# download libraries, the comment out (#) by highlighting packages and pressing CMD + Shift + C
# install.packages("Hmisc")
# install.packages("tidyverse")
# install.packages("readxl")
# install.packages("ggplot2")
# install.packages("janitor")
# install.packages("psych")
# install.packages("likert")
# install.packages("stringr")
# install.packages("wesanderson")
# install.packages("RColorBrewer")
# install.packages("scales")
# install.packages("remotes") #to install ggradar
# remotes::install_github("ricardo-bion/ggradar")

# load libraries
library(Hmisc)
library(tidyverse)
library(readxl)
library(ggplot2)
library(janitor)
library(psych)
library(likert)
library(stringr)
library(wesanderson) # http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
library(RColorBrewer)
library(scales)
library(ggradar)

```

Get and set working directory
-----------------------------
```{r}
# get working directory
getwd()

# set working directory
setwd("/Users/alison/Documents/R_scripts")
getwd()
```

Load and organise data
----------------------
```{r}
# load data
data <- read.csv("practiceForMia.csv") 

# remove all unecessary columns
data <- data[-c(1:18)] # removes columns 1:18

# rename columns
names(data) <- c(
  #passiveFight - concept highlight
  "concept1_like_text",
  "concept1_dislike_text",
  #passiveFight - statements
  "concept1_statement_funPlaying",
  "concept1_statement_tooSimilar",
  "concept1_statement_easyUnderstand",
  "concept1_statement_progressFurther",
  "concept1_statement_objMotivate",
  "concept1_statement_objNotWorthTime",
  "concept1_statement_destroyExcited",
  "concept1_statement_likeCompletingObj",
  #passiveFight - appeal and intent to play
  "concept1_appeal",
  "concept1_notAppeal_text",
  "concept1_intent",
  #treasureTrove - concept highlight
  "concept2_like_text",
  "concept2_dislike_text",
  #treasureTrove - statements
  "concept2_statement_funPlaying",
  "concept2_statement_tooSimilar",
  "concept2_statement_easyUnderstand",
  "concept2_statement_progressFurther",
  "concept2_statement_prizeWantToWin",
  "concept2_statement_prizeNotMotivate",
  "concept2_statement_prizeShareNotUnderstood",
  "concept2_statement_prizeWinnersOnly",
  #treasureTrove - appeal and intent to play
  "concept2_appeal",
  "concept2_notAppeal_text",
  "concept2_intent",
  #motivations
  "mot_competition",
  "mot_community",
  "mot_challenge",
  "mot_strategy",
  "mot_completion",
  "mot_power",
  "mot_design",
  "mot_discovery",
  "mot_story",
  "mot_fantasy",
  "mot_destruction",
  "mot_excitement",
  "other_mot",
  "otherText_mot",
  #fave types of mobile games
  "type_action",
  "type_casino",
  "type_match",
  "type_MOBA",
  "type_music",
  "type_puzzle",
  "type_racing",
  "type_RPG",
  "type_sandbox",
  "type_simulation",
  "type_shooter",
  "type_slingshot",
  "type_sports",
  "type_strategy",
  "type_tabletop",
  "type_wordGames",
  "other_type",
  "otherText_type",
  #demographics
  "age",
  "gender",
  "anythingElse_text"
  )

# add an ID column at the start
data$ID <- seq.int(nrow(data)) # add in ID column

data <- data %>% # move ID to first column
  select(ID, everything()) 

```


-----------------------------------------------------
Create a bar chart for a single choice question (SCQ)
-----------------------------------------------------

Basic graph manually coded from scratch
---------------------------------------
Example - Age
```{r}
#Create dataframe
data_bar_age <- data %>%
  #select column
  select(age) %>%
  #remove any blanks
  filter(age != "") %>%
  #remove any NAs
  na.omit() %>%
  #count number of occurrences
  count(age) 

# plot dodge bar chart
ggplot(data_bar_age, 
       #add the rating as the x-axis (appeal)
       aes(x = age,
           #add y-axis variable
           y = n)) +
  #specify which type of graph you want (dodge graph)
  geom_col(position = "dodge") 

```


Customised graph manually coded from scratch with all the bells and whistles 
----------------------------------------------------------------------------
Example 1 - Age
---------------
```{r}
#Create dataframe
data_bar_age2 <- data %>%
  #select column
  select(age) %>%
  #remove any blanks
  filter(age != "") %>%
  #remove any NAs
  na.omit() %>%
  #remove redundent values, e.g. prefer not to answer 
  filter(age != "Prefer not to answer") %>%
  #count number of occurrences
  count(age) %>%
  #calculate the % and create the value labels in the format 'X% (n)'
  mutate(
   perc = round(n/sum(n) * 100, 0),
   res = str_c(perc, "%", " (", n, ")"), 
   age = as.factor(age)) %>%
  #add column containing only n_total
  mutate(n_total = sum(n)) 

# calculate CIs (error bars)
data_bar_age2 <- cbind(
  #calculate CIs and bind this to the dataframe
  data_bar_age2, 
  binconf(data_bar_age2$n, data_bar_age2$n_total)) %>% 
  #multiply CIs by 100
  mutate_at(vars(PointEst:Upper), .funs = funs(. * 100)) 

# create customisable scales for the different labels
x_levels = c(
  "Under 18", #last positiion
  "18 - 24",
  "25 - 34",
  "35 - 44",
  "45 - 54",
  "55 - 64",
  "65 or above") #first position
x_name = "Age" #x-axis title
y_name = "Percentage (count)" #y-axis title
hjust_value = -1.3 # adjust the gap between CIs and value labels - sometimes the value labels can overlap the CIs
y_limit_min = 0 #adjust the y-axis scale minimum
y_limit_max = 60 #adjust the y-axis scale maximum

# plot dodge bar chart
ggplot(data_bar_age2,
       #add the rating as the x-axis (appeal)
       aes(x = factor(age,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels),
           #add y-axis variable
           y = perc,
           #add the colours 
           fill = factor(age,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels))) +
  #choose type of bar graph
  geom_bar(stat = "identity") +
  #remove fill legend
  theme(legend.position = "none") + 
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in the CIs (error bars)
  geom_errorbar(aes(ymin = Lower,
                     ymax = Upper),
                position = position_dodge(0.9),
                width = 0.25) +
  #add in the CIs text: X% (n)
  geom_text(aes(label = res), 
            #adjust the gap between numbers and CIs
            hjust = hjust_value,
            #adjust the font size
            size = 3, 
            #adjust the position of the error bar text to the bar
            position = position_dodge(0.9)) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name,
                     #adjust y-axis scale
                     limits = c(y_limit_min, y_limit_max)) 


# plot dodge bar chart with different colours: http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
ggplot(data_bar_age2,
       #add the rating as the x-axis (appeal)
       aes(x = factor(age,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels),
           #add y-axis variable
           y = perc,
           #add the colours 
           fill = factor(age,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels))) +
  #choose type of bar graph
  geom_bar(stat = "identity") +
  #remove fill legend
  theme(legend.position = "none") + 
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in the CIs (error bars)
  geom_errorbar(aes(ymin = Lower,
                     ymax = Upper),
                position = position_dodge(0.9),
                width = 0.25) +
  #add in the CIs text: X% (n)
  geom_text(aes(label = res), 
            #adjust the gap between numbers and CIs
            hjust = hjust_value,
            #adjust the font size
            size = 3, 
            #adjust the position of the error bar text to the bar
            position = position_dodge(0.9)) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name,
                     #adjust y-axis scale
                     limits = c(y_limit_min, y_limit_max)) +
  #add different colours to the legend from the RColorBrewer package 
  scale_fill_brewer(palette = "Dark2")

```

Example 2 - Concept 1 appeal 
----------------------------
Good to use if there are missing values for variables
```{r}
#Create dataframe
data_bar_concept1appeal <- data %>%
  #select column
  select(concept1_appeal) %>%
  #remove any blanks
  filter(concept1_appeal != "") %>%
  #remove any NAs
  na.omit() %>%
  #count number of occurrences
  count(concept1_appeal) %>%
  #calculate the % and create the value labels in the format 'X% (n)'
  mutate(
   perc = round(n/sum(n) * 100, 0),
   res = str_c(perc, "%", " (", n, ")"), 
   concept1_appeal = as.factor(concept1_appeal)) %>%
  #add column containing only n_total
  mutate(n_total = sum(n)) 

# calculate CIs (error bars)
data_bar_concept1appeal <- cbind(
  #calculate CIs and bind this to the dataframe
  data_bar_concept1appeal, 
  binconf(data_bar_concept1appeal$n, data_bar_concept1appeal$n_total)) %>% 
  #multiply CIs by 100
  mutate_at(vars(PointEst:Upper), .funs = funs(. * 100)) 

# add extra row for "Not appealing at all"
extraRow_appeal <- data.frame("Not appealing at all", 0, 0, "0% (0)", 0, 0, 0, 0)
names(extraRow_appeal) <- c("concept1_appeal", "n", "perc", "res","n_total", "PointEst", "Lower", "Upper")
data_bar_concept1appeal2 <- rbind(data_bar_concept1appeal, extraRow_appeal)
data_bar_concept1appeal <- data_bar_concept1appeal2

# create customisable scales for the different labels
x_levels = c(
  "Not appealing at all", #last positiion
  "Not very appealing",
  "Neutral",
  "Somewhat appealing",
  "Extremely appealing") #first position
x_name = "Concept 1 appeal ratings" #x-axis title
y_name = "Percentage (count)" #y-axis title
hjust_value = -1.3 # adjust the gap between CIs and value labels - sometimes the value labels can overlap the CIs
y_limit_min = 0 #adjust the y-axis scale minimum
y_limit_max = 60 #adjust the y-axis scale maximum

# plot dodge bar chart
ggplot(data_bar_concept1appeal,
       #add the rating as the x-axis (appeal)
       aes(x = factor(concept1_appeal,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels),
           #add y-axis variable
           y = perc,
           #add the colours 
           fill = factor(concept1_appeal,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels))) +
  #choose type of bar graph
  geom_bar(stat = "identity") +
  #remove fill legend
  theme(legend.position = "none") + 
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in the CIs (error bars)
  geom_errorbar(aes(ymin = Lower,
                     ymax = Upper),
                position = position_dodge(0.9),
                width = 0.25) +
  #add in the CIs text: X% (n)
  geom_text(aes(label = res), 
            #adjust the gap between numbers and CIs
            hjust = hjust_value,
            #adjust the font size
            size = 3, 
            #adjust the position of the error bar text to the bar
            position = position_dodge(0.9)) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name,
                     #adjust y-axis scale
                     limits = c(y_limit_min, y_limit_max)) 

# plot dodge bar chart with a Wes Anderson theme: http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
ggplot(data_bar_concept1appeal,
       #add the rating as the x-axis (appeal)
       aes(x = factor(concept1_appeal,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels),
           #add y-axis variable
           y = perc,
           #add the colours 
           fill = factor(concept1_appeal,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels))) +
  #choose type of bar graph
  geom_bar(stat = "identity") +
  #remove fill legend
  theme(legend.position = "none") + 
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in the CIs (error bars)
  geom_errorbar(aes(ymin = Lower,
                     ymax = Upper),
                position = position_dodge(0.9),
                width = 0.25) +
  #add in the CIs text: X% (n)
  geom_text(aes(label = res), 
            #adjust the gap between numbers and CIs
            hjust = hjust_value,
            #adjust the font size
            size = 3, 
            #adjust the position of the error bar text to the bar
            position = position_dodge(0.9)) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name,
                     #adjust y-axis scale
                     limits = c(y_limit_min, y_limit_max)) +
  #add different colours to the legend from the Wes Anderson package 
  scale_fill_manual(
    #specify that it's the Wes Anderson palette
    values = wes_palette(
      #change the number of colours (Wes Anderson colours contain 4-5 colours)
      n = 5, 
      #choose the Wes Anderson theme
      name = "Zissou1"))

```


--------------------
SCQ using a function
--------------------

Example - Gender 
----------------
Run the function for a SCQ that calculates the % and CIs (error bars), and then plots a graph
```{r}
scqGraph_defaultColours <- function(dataframe, var) {
  temp <- dataframe %>%
    count(!!sym(var)) %>%
    #calculate percentages
    mutate(
      perc = round(n/sum(n) * 100, 0),
      res = str_c(perc, "%", " (", n, ")")) %>%
    #add a column containing only n_total
    mutate(n_total = sum(n)) 

  # calculate CIs (error bars)
  temp <- cbind( 
    temp,
    binconf(temp$n, temp$n_total)) %>% 
    #multiply CIs by 100
    mutate_at(vars(PointEst:Upper), .funs = funs(. * 100))
  
  #plot dodge bar chart 
  ggplot(temp, 
         #reorder x-axis names high to low by n
         aes(x = factor(!!sym(var), 
                        levels = x_levels),
             #add in y-axis
             y = perc,
             #reorder default fill colours high to low by n
             fill = factor(!!sym(var), 
                           levels = x_levels))) +  
    #choose type of bar graph
    geom_bar(stat = "identity") +
    #remove fill legend
    theme(legend.position = "none") + 
    #flip the bar graph to be horizontal
    coord_flip() +
    #add in the CIs (error bars)
    geom_errorbar(aes(ymin = Lower,
                      ymax = Upper),
                  #adjust the position of the error bars to the bar
                  position = position_dodge(0.9),
                  width = 0.25) +
    #add in the CIs text: X% (n)
    geom_text(aes(label = res),
              #adjust the gap between numbers and CIs
              hjust = hjust_value,
              #adjust the font size
              size = 3, 
              #change the font colour
              #colour = "white",
              #adjust the position of the error bar text to the bar
              position = position_dodge(0.9)) +
    #add the x-axis name 
    scale_x_discrete(name = x_name) +
    #add the y-axis name
    scale_y_continuous(name = y_name,
                       #adjust y-axis scale
                       limits = c(y_limit_min, y_limit_max))  
}

```

Plot gender
```{r}
#Create dataframe
data_bar_func_gender <- data %>%
  #select column
  select(gender) %>%
  #remove any blanks
  filter(gender != "") %>%
  #remove any NAs
  na.omit() %>%
  #remove redundent values, e.g. prefer not to answer 
  filter(gender != "Prefer not to answer")

# create customisable scales for each graph
x_levels = c(
  "Other / Non-binary", #last positiion
  "Female",
  "Male") #first position
x_name = "Gender"
y_name = "Percentage (count)"
hjust_value = -1.3
y_limit_min = 0
y_limit_max = 100

# run function
scqGraph_defaultColours(data_bar_func_gender,"gender")
```


==========================================================================
Practice time!
==========================================================================
Using data from a previous survey for a SCQ:

1. Create a new R Markdown file (File -> New File -> R Markdown)
2. Save your new R Markdown file in a folder
3. Copy your data to the same folder
4. Install and load all the necessary packages
5. Set your working directory
6. Load and organise your data (homework - we'll use this data for today)
7. Plot a basic graph from scratch
8. Add all the bells and whistles either manually and / or with a function
========================================================================== 


-------------------------------------------------
Create a bar chart comparing two groups for a SCQ
-------------------------------------------------

Basic graph manually coded from scratch
---------------------------------------
```{r}
# Gather columns and update value names into sepatate dfs before running function
data_bar_concept_basic_appeal <- data %>% #load the data into a new dataframe
  #specify the columns you want in your new dataframe
  dplyr::select(ID, 
                concept1_appeal,
                concept2_appeal) %>%
  #gather the columns into a new set
  gather(key = "concept", value = "appeal", 2:3) %>%
  group_by(concept, appeal) %>%
  #summarise the appeal responses and group them by concept
  summarise(n = n()) %>%
  #remove any blanks
  filter(appeal != "") %>% 
  #remove any NA values  
  na.omit() %>%
  #calculate the total n in each group
  group_by(concept) %>% 
  #calculate total in each group
  mutate(n_total = sum(n)) 

# plot dodge bar chart
ggplot(data_bar_concept_basic_appeal, 
       #add the rating as the x-axis (appeal)
       aes(x = appeal,
           #add y-axis variable
           y = n,
           #add the groups, which in this case will be the concept, but we'll use a variable to define this here 
           fill = concept)) + 
  #specify which type of graph you want (dodge graph)
  geom_col(position = "dodge") 

```

Customised graph manually coded from scratch with all the bells and whistles 
----------------------------------------------------------------------------
```{r}
# Gather columns and update value names into sepatate dfs before running function
data_bar_concept_appeal <- data %>% #load the data into a new dataframe
  #specify the columns you want in your new dataframe
  dplyr::select(ID, 
                concept1_appeal,
                concept2_appeal) %>%
  #gather the columns into a new set
  gather(key = "concept", value = "appeal", 2:3) %>%
  #summarise the appeal responses and group them by concept
  group_by(concept, appeal) %>%
  summarise(n = n()) %>%
  #remove any blanks
  filter(appeal != "") %>% 
  #rename concepts 1 and 2 values to the actual name of the concepts
  mutate(
    concept = str_replace_all(concept, fixed("concept1_appeal"), "Pig's Fight")) %>%
  mutate(
    concept = str_replace_all(concept, fixed("concept2_appeal"), "Pig's Treasure Trove")) %>%
  #remove any NA values  
  na.omit() %>%
  #calculate the total n in each group
  group_by(concept) %>% #calculate total in each group
  mutate(n_total = sum(n)) %>%
  #calculate the % and create the value labels in the format 'X% (n)'
  group_by(concept) %>% #calculate % 
  mutate(
    perc = round(proportions(n) * 100, 0),
    res = str_c(perc, "%", " (", n, ")"),
    concept = as.factor(concept)) 

# calculating CIs (error bars)
data_bar_concept_appeal <- cbind(
  data_bar_concept_appeal,
  binconf(data_bar_concept_appeal$n,
  data_bar_concept_appeal$n_total)) 

# multiply CIs by 100
data_bar_concept_appeal <- data_bar_concept_appeal %>% #multiply CIs by 100
  mutate_at(vars(PointEst:Upper),
            .funs = funs(. * 100))

# reorder the fill labels 
data_bar_concept_appeal$concept <- factor(
  data_bar_concept_appeal$concept,
  levels = c("Pig's Treasure Trove", #position 2
             "Pig's Fight")) #position 1

# create customisable scales for the different labels
x_levels = c(
  "Not appealing at all", #manually ordered
  "Not very appealing",
  "Neutral",
  "Somewhat appealing",
  "Extremely appealing")
x_name = "Concept appeal ratings" #x-axis title
y_name = "Percentage (count)" #y-axis title
fill_name = "Concept" #legend title
hjust_value = -0.7 # adjust the gap between CIs and value labels - sometimes the value labels can overlap the CIs

# plot dodge bar chart
ggplot(data_bar_concept_appeal, 
       #add the rating as the x-axis (appeal)
       aes(x = factor(appeal,
                      #add a variable to plot the names of the x-axis (appeal ratings)
                      levels = x_levels),
           #add y-axis variable
           y = PointEst,
           #add the groups, which in this case will be the concept, but we'll use a variable to define this here 
           fill = concept)) + 
  #specify which type of graph you want (dodge graph)
  geom_col(position = "dodge") +
  #flip the coordinates so the graph is a horizontal graph
  coord_flip() +
  #add the CIs (error bars) to the graph
  geom_errorbar(aes(ymin = Lower, #specify lower CI
                     ymax = Upper), #specify upper CI
                position = position_dodge(0.9), #specify the position of the CIs on the bars
                width = 0.25) + #specify how wide the CIs should be
  #add the value labels -->'X% (n)'
  geom_text(aes(label = res),
            #gap between CI bars and numbers
            hjust = hjust_value, 
            #font size
            size = 3, 
            #position of the labels in relation to each bar
            position = position_dodge(0.9)) +
  #reverses legend to match graph after coord_flip()
  guides(fill = guide_legend(reverse = TRUE)) + 
  #add a custom name to the x-axis
  scale_x_discrete(name = x_name) +
  #add a custom name to the y-axis
  scale_y_continuous(name = y_name,
                     #extend the limits by 30% (1.3)
                     limits = c(0, max(data_bar_concept_appeal$PointEst)*1.3)) +
  #add a custom name to the legend
  scale_fill_discrete(name = fill_name)


```


-----------------------------------------
SCQ comparing two groups using a function
-----------------------------------------

Run the function for a SCQ 
--------------------------
Calculates the % and CIs (error bars), and then plots a graph
```{r}
#name the function and that it's going to contain a dataframe and a variable
scqGraph_compareGroups <- function(dataframe, var) { 
  #create a temporary dataframe
  temp <- dataframe %>% 
    #summarise the appeal responses and group them by rating
    group_by(!!sym(var), rating) %>% 
    summarise(n = n()) %>%
    #remove any NA values  
    na.omit() %>% 
    #calculate the total n in each group
    group_by(!!sym(var)) %>% 
    mutate(n_total = sum(n)) %>%
    #calculate the % and create the value labels in the format 'X% (n)'
    group_by(!!sym(var)) %>%  
    mutate(
      perc = round(proportions(n) * 100, 0),
      res = str_c(perc, "%", " (", n, ")"),
      !!sym(var) := as.factor(!!sym(var))
    ) 

  #calculate the CIs (error bars)
  temp <- cbind( 
    temp,
    binconf(temp$n,
    temp$n_total)) 
  
  #as we're using %, we want the CIs to take this into account - multiply CIs by 100.
  temp <- temp %>% 
    mutate_at(vars(PointEst:Upper),
              .funs = funs(. * 100))
  
  #plot a 'dodge' bar chart
  ggplot(temp, #use temp data
         #add the rating as the x-axis (appeal ratings)
         aes(x = factor(rating,
                 #add a variable to plot the names of the x-axis (appeal ratings)      
                 level = x_levels),
             #add the y-axis (results)
             y = PointEst,
             #add the groups, which in this case will be the concept, but we'll use a variable to define this here 
             fill = !!sym(var))) + 
    #specify which type of graph you want (dodge graph)
    geom_col(position = "dodge") +
    #flip the coordinates so the graph is a horizontal graph
    coord_flip() +
    #add the CIs (error bars) to the graph
    geom_errorbar(aes(ymin = Lower, #specify lower CI
                       ymax = Upper), #specify upper CI
                  position = position_dodge(0.9), #specify the position of the CIs on the bars
                  width = 0.25) + #specify how wide the CIs should be
    #add the value labels -->'X% (n)'
    geom_text(aes(label = res), 
              #gap between CI bars and numbers
              hjust = hjust_value, 
              #font size
              size = 3, 
              #position of the labels in relation to each bar
              position = position_dodge(0.9)) +
    #swap the legend around to match graph after coord_flip()
    guides(fill = guide_legend(reverse = TRUE)) + 
    #add a custom name to the x-axis
    scale_x_discrete(name = x_name) +
    #add a custom name to the y-axis
    scale_y_continuous(name = y_name,
                       #extend the limits by 30% (1.3)
                       limits = c(0, max(temp$PointEst)*1.3)) +
    #add a custom name to the legend
    scale_fill_discrete(name = fill_name)
}

```

Example 1 - Concept appeal
--------------------------
```{r}
# Gather columns and update value names into sepatate dfs before running function
data_bar_func_concept_appeal <- data %>% #load the data into a new dataframe
  #specify the columns you want in your new dataframe
  dplyr::select(ID, 
                concept1_appeal,
                concept2_appeal) %>%
  #gather the columns into a new set
  gather(key = "concept", value = "appeal", 2:3) %>%
  #remove any blanks
  filter(appeal != "") %>% 
  #rename concepts 1 and 2 values to the actual name of the concepts
  mutate(
    concept = str_replace_all(concept, fixed("concept1_appeal"), "Pig's Fight")) %>%
  mutate(
    concept = str_replace_all(concept, fixed("concept2_appeal"), "Pig's Treasure Trove")) %>%
  #rename the column name to 'rating' for the function to work
  rename(
    "rating" = appeal)

# reorder the fill labels
data_bar_func_concept_appeal$concept <- factor(
  data_bar_func_concept_appeal$concept,
  levels = c("Pig's Treasure Trove", #position 2
             "Pig's Fight")) #position 1

# create customisable scales for the different labels
x_levels = c(
  "Not appealing at all", #manually ordered
  "Not very appealing", 
  "Neutral",
  "Somewhat appealing",
  "Extremely appealing")
x_name = "Concept appeal ratings"
y_name = "Percentage (count)"
fill_name = "Concept"
# fill_labels = c("Pig's Treasure Trove", #position 2
#                 "Pig's Fight") #position 1
hjust_value = -0.7 # adjust the gap between CIs and value labels - sometimes the value labels can overlap the CIs

# specify the data and the variable, in this case "concept", then call the function
scqGraph_compareGroups(data_bar_func_concept_appeal,"concept") 

```

Example 2 - Intent to play concept
----------------------------------
```{r}
# Gather columns and update value names into sepatate dfs before running function
data_bar_func_concept_intent <- data %>% #load the data into a new dataframe
  #specify the columns you want in your new dataframe
  dplyr::select(ID, 
                concept1_intent,
                concept2_intent) %>%
  #gather the columns into a new set
  gather(key = "concept", value = "intent", 2:3) %>%
  #remove any blanks
  filter(intent != "") %>% 
  #rename concepts 1 and 2 values to the actual name of the concepts
  mutate(
    concept = str_replace_all(concept, fixed("concept1_intent"), "Pig's Fight")) %>%
  mutate(
    concept = str_replace_all(concept, fixed("concept2_intent"), "Pig's Treasure Trove")) %>%
   rename(
    "rating" = intent)

# reorder the fill labels
data_bar_func_concept_intent$concept <- factor(
  data_bar_func_concept_intent$concept,
  levels = c("Pig's Treasure Trove", #position 2
             "Pig's Fight")) #position 1

# create customisable scales for the different labels
x_levels = c(
  "Definitely would not", #manually ordered
  "Probably would not", 
  "Might",
  "Probably would",
  "Definitely would")
x_name = "'Intent to play' ratings"
y_name = "Percentage (count)"
fill_name = "Concept"
# fill_labels = c("Pig's Treasure Trove", #position 2
#                 "Pig's Fight") #position 1
hjust_value = -0.7 # adjust the gap between CIs and value labels - sometimes the value labels can overlap the CIs

# specify the data and the variable, in this case "concept", then call the function
scqGraph_compareGroups(data_bar_func_concept_intent,"concept")

```


==========================================================================
Practice time!
==========================================================================
Using data from a previous survey for a SCQ comparing 2 groups:

1. Copy your data to the same folder
2. Load and organise your data (homework - we'll use this data for today)
3. Plot a basic graph from scratch
4. Add all the bells and whistles either manually and / or with a function
========================================================================== 


-------------------------------------------------
Plotting multiple-choice questions (MCQ) manually
-------------------------------------------------

Example 1 - Motivations
-----------------------
```{r}
#create dataframe
data_bar_motivations <- data %>% 
#select all motivation columns, which contain "mot_"
  select(
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) %>%
  #count the number of occurrences  
  count(motivations) %>%
  #calculate percentages
  mutate(
   perc = round(n/sum(n) * 100, 0),
   res = str_c(perc, "%", " (", n, ")")) %>%
  #add a column containing only n_total
  mutate(n_total = sum(n)) %>% 
  #order the n descending
  arrange(desc(n)) 
  
# calculate CIs (error bars)
data_bar_motivationsCI <- cbind(
  #calculate CIs and bind this to the dataframe
  data_bar_motivations, 
  binconf(data_bar_motivations$n, data_bar_motivations$n_total)) %>% 
  #multiply CIs by 100
  mutate_at(vars(PointEst:Upper), .funs = funs(. * 100)) 

# plot bar chart
ggplot(data_bar_motivationsCI, 
       #reorder x-axis names high to low by n
       aes(x = reorder(motivations, n), 
           #add in y-axis
           y = perc,
           #reorder default fill colours high to low by n
           fill = reorder(motivations, n))) + 
  #choose type of bar graph
  geom_bar(stat = "identity") +
  #remove fill legend
  theme(legend.position = "none") + 
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in the CIs (error bars)
  geom_errorbar(aes(ymin = Lower,
                     ymax = Upper),
                #adjust the position of the error bars to the bar
                position = position_dodge(0.9),
                width = 0.25) +
  #add in the CIs text: X% (n)
  geom_text(aes(label = res),
            #adjust the gap between numbers and CIs
            hjust = -1.3,
            #adjust the font size
            size = 3, 
            #adjust the position of the error bar text to the bar
            position = position_dodge(0.9)) +
  #add the x-axis name 
  scale_x_discrete(name = "Motivations") +
  #add the y-axis name
  scale_y_continuous(name = "Percentage (count)",
                     #adjust y-axis scale
                     limits = c(0, 25)) 

```


Example 2 - Motivations by concept 1 appeal in a stacked bar graph
------------------------------------------------------------------
Good to use if there are missing values for variables
```{r}
#create dataframe
data_bar_motivations_concept1appeal <- data %>%  
  #select concept column and all motivation columns, which contain "mot_"
  dplyr::select(
    concept1_appeal,
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  group_by(concept1_appeal) %>%
  #replace all blanks with NA
  pivot_longer(contains("mot_"), names_to = "group") %>%
  #remove any blanks / NAs by replacing blanks with "NA", then removing the NAs
  mutate_if(is.character, list(~na_if(., ""))) %>% 
  dplyr::filter(!is.na(value)) %>% 
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  dplyr::select(-value) %>%
  #remove the "_mot"
  mutate(
    group = str_replace_all(group, "mot_", "")) %>%
  #count the number of occurrences by concept appeal using the function - summarize
  group_by(
    group, 
    concept1_appeal) %>%
  dplyr::summarize(n = n()) %>%
  #calculate the total n by concept appeal
  group_by(group) %>%
  mutate(n_total = sum(n)) %>% 
  #calculate percentages by concept appeal
  mutate(
    perc = round(proportions(n) * 100, 0),
    res = str_c(perc, "%", " (", n, ")"),
    group = as.factor(group)) 

# If there is 0 for some values, but we still want to show these values in the legend, we can add an additional row of 0s
# -----------------------------------------------------------------------------------------------------------------------
#create a single extra row for "Not appealing at all"
extraRow_mot_appeal <- data.frame("challenge", "Not appealing at all", 0, 0, 0, "0% (0)")
#add column names to the row
names(extraRow_mot_appeal) <- c("group", "concept1_appeal", "n", "n_total", "perc", "res")
#bind the extra row to the above dataframe and give it a new name
data_bar_motivations_concept1appeal2 <- rbind(data_bar_motivations_concept1appeal, extraRow_mot_appeal)
#rename the dataframe to the old dataframe
data_bar_motivations_concept1appeal <- data_bar_motivations_concept1appeal2

# create customisable scales for each graph
data_bar_motivations_concept1appeal$concept1_appeal <- factor( 
  data_bar_motivations_concept1appeal$concept1_appeal,
  #order the fill levels
  levels = c(
    "Not appealing at all", #last positiion
    "Not very appealing",
    "Neutral",
    "Somewhat appealing",
    "Extremely appealing")) #first position
x_name = "Motivations"
y_name = "Percentage (count)"
fill_name = "Pig's Fight concept appeal"
hjust_value = -1.3

# Show the numbers only if percentage is below a certain amount
# -------------------------------------------------------------
#add in the minimum % value 
bar_value <- 15
#create 'ifelse' statement so values that only values that are equal to or more than this stated value are shown
bar_valueText <- ifelse(data_bar_motivations_concept1appeal$perc < bar_value, NA, data_bar_motivations_concept1appeal$res)

# plot bar chart
# --------------
ggplot(data_bar_motivations_concept1appeal, 
       #add x-axis
       aes(x = group,
         #add y-axis   
         y = perc, 
         #add fill
         fill = concept1_appeal)) + 
  #define type of plot - stacked  
  geom_bar(stat = "identity") +
  #flip the bar graph to be horizontal
  coord_flip() +
  #add in text based on 'ifelse' statement above
  geom_text(aes(label = bar_valueText),
            position = position_stack(vjust = 0.5),
            colour = "white",
            size = 3) +
  #swap around the order of the legend (legend swaps the order when we use coord_flip)
  guides(fill = guide_legend(reverse = TRUE)) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name) +
  #add the fill name
  scale_fill_discrete(name = fill_name)

```

Example 3 - Motivations by concept 1 appeal in a facet graph 
------------------------------------------------------------
Good to use if the graph is looking complex and you'd like to have multiple graphs
```{r}
# NOTE: The below code up to the facet graph is the same as Example 2 above
# -------------------------------------------------------------------------
#create dataframe
data_bar_motivations_concept1appeal <- data %>%  
  #select concept column and all motivation columns, which contain "mot_"
  dplyr::select(
    concept1_appeal,
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  group_by(concept1_appeal) %>%
  #replace all blanks with NA
  pivot_longer(contains("mot_"), names_to = "group") %>%
  #remove any blanks / NAs by replacing blanks with "NA", then removing the NAs
  mutate_if(is.character, list(~na_if(., ""))) %>% 
  dplyr::filter(!is.na(value)) %>% 
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  dplyr::select(-value) %>%
  #remove the "_mot"
  mutate(
    group = str_replace_all(group, "mot_", "")) %>%
  #count the number of occurrences by concept appeal using the function - summarize
  group_by(
    group, 
    concept1_appeal) %>%
  dplyr::summarize(n = n()) %>%
  #calculate the total n by concept appeal
  group_by(group) %>%
  mutate(n_total = sum(n)) %>% 
  #calculate percentages by concept appeal
  mutate(
    perc = round(proportions(n) * 100, 0),
    res = str_c(perc, "%", " (", n, ")"),
    group = as.factor(group)) 

# If there is 0 for some values, but we still want to show these values in the legend, we can add an additional row of 0s
# -----------------------------------------------------------------------------------------------------------------------
#create a single extra row for "Not appealing at all"
extraRow_mot_appeal <- data.frame("challenge", "Not appealing at all", 0, 0, 0, "0% (0)")
#add column names to the row
names(extraRow_mot_appeal) <- c("group", "concept1_appeal", "n", "n_total", "perc", "res")
#bind the extra row to the above dataframe and give it a new name
data_bar_motivations_concept1appeal2 <- rbind(data_bar_motivations_concept1appeal, extraRow_mot_appeal)
#rename the dataframe to the old dataframe
data_bar_motivations_concept1appeal <- data_bar_motivations_concept1appeal2

# create customisable scales for each graph
data_bar_motivations_concept1appeal$concept1_appeal <- factor( 
  data_bar_motivations_concept1appeal$concept1_appeal,
  #order the fill levels
  levels = c(
    "Not appealing at all", #last positiion
    "Not very appealing",
    "Neutral",
    "Somewhat appealing",
    "Extremely appealing")) #first position
x_name = "Motivations"
y_name = "Percentage (count)"
fill_name = "Pig's Fight concept appeal"
hjust_value = -1.3

# Create a facet wrap graph
# -------------------------
# plot facet plot
ggplot(data_bar_motivations_concept1appeal,
       #add x-axis
       aes(x = concept1_appeal,
           #add y-axis
           y = perc,
           #add fill
           fill = group)) + 
    #define type of plot - dodge
    geom_bar(stat = "identity") +
  #add facet plot
  facet_wrap(~group) +
  #flip the bar graph to be horizontal
  coord_flip() +
  #remove legend
  theme(legend.position = "none") +
  #add in the text: X% (n)
  geom_text(aes(label = res),
            #adjust the gap between numbers and bars
            hjust = -0.1,
            #adjust the font size
            size = 3) +
  #add the x-axis name
  scale_x_discrete(name = x_name) +
  #add the y-axis name
  scale_y_continuous(name = y_name,
                     #define y-axis range to allow space for the numbers
                     limits = c(0, 100))

```

--------------------
MCQ using a function
--------------------

Run the function for a MCQ 
--------------------------------------------------
Calculates the % and CIs (error bars), and then plots a graph
```{r}
#name the function and that it's going to contain a dataframe and a variable
mcqGraph_defaultColours <- function(dataframe, var) {
  temp <- dataframe %>%
    count(!!sym(var)) %>%
    #calculate percentages
    mutate(
      perc = round(n/sum(n) * 100, 0),
      res = str_c(perc, "%", " (", n, ")")) %>%
    #add a column containing only n_total
    mutate(n_total = sum(n)) %>% 
    #order the n descending
    arrange(desc(n))

  # calculate CIs (error bars)
  temp <- cbind( 
    temp,
    binconf(temp$n, temp$n_total)) %>% 
    #multiply CIs by 100
    mutate_at(vars(PointEst:Upper), .funs = funs(. * 100))
  
  #plot dodge bar chart 
  ggplot(temp, 
         #reorder x-axis names high to low by n
         aes(x = reorder(!!sym(var), n),
             #add in y-axis
             y = perc,
             #reorder default fill colours high to low by n
             fill = reorder(!!sym(var), n))) +  
    #choose type of bar graph
    geom_bar(stat = "identity") +
    #remove fill legend
    theme(legend.position = "none") + 
    #flip the bar graph to be horizontal
    coord_flip() +
    #add in the CIs (error bars)
    geom_errorbar(aes(ymin = Lower,
                      ymax = Upper),
                  #adjust the position of the error bars to the bar
                  position = position_dodge(0.9),
                  width = 0.25) +
    #add in the CIs text: X% (n)
    geom_text(aes(label = res),
              #adjust the gap between numbers and CIs
              hjust = hjust_value,
              #adjust the font size
              size = 3, 
              #change the font colour
              #colour = "white",
              #adjust the position of the error bar text to the bar
              position = position_dodge(0.9)) +
    #add the x-axis name 
    scale_x_discrete(name = x_name) +
    #add the y-axis name
    scale_y_continuous(name = y_name,
                       #adjust y-axis scale
                       limits = c(y_limit_min, y_limit_max))  
}

```

Example 1 - Motivations
-----------------------
```{r}
#create dataframe
data_bar_func_motivations <- data %>% 
#select all motivation columns, which contain "mot_"
  select(
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) 
  
# create customisable scales for each graph
x_name = "Motivations"
y_name = "Percentage (count)"
hjust_value = -1.3
y_limit_min = 0
y_limit_max = 25

# run function
mcqGraph_defaultColours(data_bar_func_motivations,"motivations")

```

Example 2 - Favourite types of games
------------------------------------
```{r}
#create dataframe
data_bar_func_typeOfGame <- data %>% 
#select all motivation columns, which contain "type_"
  select(
    contains("type_")) %>%
  #pivot the columns and rename the column to "type_col"
  pivot_longer(contains("type_"), names_to = "type_col") %>% 
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(value != "") %>%
  #remove the redundant extra "type_col" so we're just left with the motivation values
  select(-type_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "type" = value) 
  
# create customisable scales for each graph
x_name = "Favourite types of games"
y_name = "Percentage (count)"
hjust_value = -1.3
y_limit_min = 0
y_limit_max = 25

# run function
mcqGraph_defaultColours(data_bar_func_typeOfGame,"type")

```


==========================================================================
Practice time!
==========================================================================
Using data from a previous survey for a MCQ:

1. Copy your data to the same folder
2. Load and organise your data (homework - we'll use this data for today)
3. Plot a basic graph from scratch
4. Add all the bells and whistles either manually and / or with a function
==========================================================================


-----------------------
Likert scale statements
-----------------------

Example 1 - Concept 1 appeal
----------------------------
```{r}
# create dataframe for statements 
# -------------------------------
#create dataframe
data_likert_concept1 <- data %>%
  #select columns that contain part of the following name (easier than listing them all out)
  select(
    contains("concept1_statement_")) %>%
  #rename the labels in all the columns to numbers - this will allow the script to calculate the % 
  mutate(across(c( #recode values in statements
    concept1_statement_funPlaying,
    concept1_statement_tooSimilar,
    concept1_statement_easyUnderstand,
    concept1_statement_progressFurther,
    concept1_statement_objMotivate,
    concept1_statement_objNotWorthTime,
    concept1_statement_destroyExcited,
    concept1_statement_likeCompletingObj),
    ~case_when(
      . == "Strongly agree" ~ 5,
      . == "Agree" ~ 4,
      . == "Neutral" ~ 3,
      . == "Disagree" ~ 2,
      . == "Strongly disagree" ~ 1))) 

# plot likert scale for all statements
# ------------------------------------
#specify the levels - in this case it's 1-5, but it could be changed to 1-7, 1-11, etc.
data_likert_concept1 <- lapply(data_likert_concept1, factor, levels = 1:5)
#change data to a 'dataframe' format
data_likert_concept1 <- as.data.frame(data_likert_concept1)
#rename the column names
data_likert_concept1_renamed <- data_likert_concept1 %>%
  rename(
    "Event is fun to play" = concept1_statement_funPlaying, #rename column names
    "Too similar to other events (neg.)" = concept1_statement_tooSimilar,
    "Event is easy to understand" = concept1_statement_easyUnderstand,
    "Event helps players progress further" = concept1_statement_progressFurther,
    "Objectives motivate players to play more" = concept1_statement_objMotivate,
    "Objectives aren't worth players' time (neg.)" = concept1_statement_objNotWorthTime,
    "Destroying structures to earn rewards is exciting" = concept1_statement_destroyExcited,
    "Players like completing these types of objectives" = concept1_statement_likeCompletingObj)
#do the calculations for the likert scale from columns 1-8
likt_concept1 <- likert(data_likert_concept1_renamed[ ,c(1:8)])
#plot the likert scale
plot(likt_concept1)

# create a shorter version without the ratings that are also in concept 2
# -----------------------------------------------------------------------
#create a new dataframe from the one above
data_likert_concept1_short <- data_likert_concept1 %>%
  #select the columns
  select(concept1_statement_objMotivate,
         concept1_statement_objNotWorthTime,
         concept1_statement_destroyExcited,
         concept1_statement_likeCompletingObj) %>%
  #rename the column
  rename(
    "Objectives motivate players to play more" = concept1_statement_objMotivate, #rename column names
    "Objectives aren't worth players' time (neg.)" = concept1_statement_objNotWorthTime,
    "Destroying structures to earn rewards is exciting" = concept1_statement_destroyExcited,
    "Players like completing these types of objectives" = concept1_statement_likeCompletingObj)
#do the calculations for the likert scale from columns 1-4 
likt_concept1_short <- likert(data_likert_concept1_short[ ,c(1:4)])
#plot the likert scale
plot(likt_concept1_short)

```


Example 2 - Concept 2 appeal
----------------------------
```{r}
# create dataframe for statements 
# -------------------------------
#create dataframe
data_likert_concept2 <- data %>%
  #select columns that contain part of the following name (easier than listing them all out)
  select(contains("concept2_statement_")) %>%
  #rename the labels in all the columns to numbers - this will allow the script to calculate the % 
  mutate(across(c(
    concept2_statement_funPlaying,
    concept2_statement_tooSimilar,
    concept2_statement_easyUnderstand,
    concept2_statement_progressFurther,
    concept2_statement_prizeWantToWin,
    concept2_statement_prizeNotMotivate,
    concept2_statement_prizeShareNotUnderstood,
    concept2_statement_prizeWinnersOnly),
    ~case_when(
      . == "Strongly agree" ~ 5,
      . == "Agree" ~ 4,
      . == "Neutral" ~ 3,
      . == "Disagree" ~ 2,
      . == "Strongly disagree" ~ 1))) 


# plot likert scale for all statements
# ------------------------------------
#specify the levels - in this case it's 1-5, but it could be changed to 1-7, 1-11, etc.
data_likert_concept2 <- lapply(data_likert_concept2, factor, levels = 1:5)
#change data to a 'dataframe' format
data_likert_concept2 <- as.data.frame(data_likert_concept2)
#rename the column names
data_likert_concept2_rename <- data_likert_concept2 %>%
  rename(
    "Event is fun to play" = concept2_statement_funPlaying, #rename column names
    "Too similar to other events (neg.)" = concept2_statement_tooSimilar,
    "Event is easy to understand" = concept2_statement_easyUnderstand,
    "Event helps players progress further" = concept2_statement_progressFurther,
    "Shared prize makes players want to win" = concept2_statement_prizeWantToWin,
    "Shared prize doesn't motivate players to play (neg.)" = concept2_statement_prizeNotMotivate,
    "Players didn't understand the shared prize (neg.)" = concept2_statement_prizeShareNotUnderstood,
    "Only winners get the prize makes players want to play" = concept2_statement_prizeWinnersOnly)
#do the calculations for the likert scale from columns 1-8
likt_concept2 <- likert(data_likert_concept2_rename[ ,c(1:8)])
#plot the likert scale
plot(likt_concept2)
#change colour (optional)
# plot(likt_concept2) +
#   scale_fill_brewer(palette = "RdBu")

# create a shorter version without the ratings that are also in concept 1
# -----------------------------------------------------------------------
#create a new dataframe from the one above
data_likert_concept2_short <- data_likert_concept2 %>%
  #select the columns
  select(concept2_statement_prizeWantToWin,
         concept2_statement_prizeNotMotivate,
         concept2_statement_prizeShareNotUnderstood,
         concept2_statement_prizeWinnersOnly) %>%
  #rename the columns
  rename(
    "Shared prize makes players want to win" = concept2_statement_prizeWantToWin, #rename column names
    "Shared prize doesn't motivate players to play (neg.)" = concept2_statement_prizeNotMotivate,
    "Players didn't understand the shared prize (neg.)" = concept2_statement_prizeShareNotUnderstood,
    "Only winners get the prize makes players want to play" = concept2_statement_prizeWinnersOnly)
#do the calculations for the likert scale from columns 1-4 
likt_concept2_short <- likert(data_likert_concept2_short[ ,c(1:4)])
#plot the likert scale
plot(likt_concept2_short)

```

Example 3 - Grouped by each concept 
-----------------------------------
```{r}
# create dataframe for concept 1 statements
# -----------------------------------------
#create dataframe
data_likert_concept1 <- data %>%
  #select columns that contain part of the following name (easier than listing them all out)
  select(contains("concept1_statement_")) %>%
  #change blanks to NAs
  mutate_all(na_if, "") %>% 
  #filter out all blank rows
  na.omit() %>% 
  #add extra column to denote the concept name
  mutate(concept = "Pig's Fight") %>% 
  #move 'concept' column to the 1st column position
  select(concept, everything()) %>%
  #remove part of string, so the column name is just the statement
  rename_with(~ str_remove(., "concept1_"), everything()) 

# create dataframe for concept 2 statements
data_likert_concept2 <- data %>%
  #select columns that contain part of the following name (easier than listing them all out)
  select(contains("concept2_statement_")) %>%
  #change blanks to NAs
  mutate_all(na_if, "") %>% 
  #filter out all blank rows
  na.omit() %>% 
  #add extra column to denote the concept name
  mutate(concept = "Pig's Treasure Trove") %>% 
  #move 'concept' column to the 1st column position
  select(concept, everything()) %>%
  #remove part of string, so the column name is just the statement
  rename_with(~ str_remove(., "concept2_"), everything()) 

# combine dfs and only keep comparison columns
data_likert_byConcept <- bind_rows(data_likert_concept1, data_likert_concept2)
#remove any NAs leftover
data_likert_byConcept <- data_likert_byConcept %>%
  select_if(~ !any(is.na(.)))

# prepare data for likert scale graph
data_likert_byConcept <- data_likert_byConcept %>%
  #rename the labels in all the columns to numbers - this will allow the script to calculate the % 
  mutate(across(c( 
    statement_funPlaying,
    statement_tooSimilar,
    statement_easyUnderstand,
    statement_progressFurther),
    ~case_when(
      . == "Strongly agree" ~ 5,
      . == "Agree" ~ 4,
      . == "Neutral" ~ 3,
      . == "Disagree" ~ 2,
      . == "Strongly disagree" ~ 1))) %>%
  #rename the columns
  rename(
    "Event is fun to play" = statement_funPlaying, #rename column names
    "Event is too similar to other events (neg.)" = statement_tooSimilar,
    "Event is easy to understand" = statement_easyUnderstand, 
    "Players feel they can progress further" = statement_progressFurther)

# plot likert scale for all statements grouped by concept
data_likert_byConcept[2:5] <- lapply(data_likert_byConcept[2:5], factor, levels = 1:5)
likt_byConcept <- likert(data_likert_byConcept[ ,c(2:5)], grouping = data_likert_byConcept$concept)
plot(likt_byConcept, 
     group.order = c("Pig's Fight", "Pig's Treasure Trove"))

```


==========================================================================
Practice time!
==========================================================================
Using data from a previous survey for a Likert scale question:

1. Copy your data to the same folder
2. Load and organise your data (homework - we'll use this data for today)
3. Plot a Likert scale for 1 group
4. Plot a Likert scale to comare 2 groups
==========================================================================

-----------------------------------
Radar / Spider graphs - motivations
-----------------------------------

Example 1 - plot for 1 group
----------------------------
```{r}
# single group radar graph for 12 primary motivations
# ---------------------------------------------------
# create a new dataframe
data_motivations12 <- data %>%
  #select all motivation columns, which contain "mot_"
  select(
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) %>%
  #count the number of occurrences  
  count(motivations) %>%
  #calculate percentages
  mutate(
   perc = round(n/sum(n) * 100, 0)) %>%
  #remove n column
  select(-n) %>%
  #pivot or "spread" the motivations column for the spider graph to work
  spread(
    key = motivations,
    value = perc) %>%
  #reorder the motivations to match the QF graph
  select(Competition, 
         Community,
         Challenge,
         Strategy,
         Completion,
         Power,
         Design,
         Discovery,
         Story,
         Fantasy,
         Destruction,
         Excitement) %>%
  #add extra column otherwise ggradar will take the first column as the group
  mutate(col = "1") %>% 
  #move the extra column to column position 1
  select(col, everything()) 

# plot radar graph
ggradar( 
  data_motivations12,
  # add in labels to the graph - check data above and adjust percentages as needed
  values.radar = c("0", "10", "20"),
  # plot the min, mid and max ranges (same as the labels)
  grid.min = 0,
  grid.mid = 10,
  grid.max = 20,
  # Change the polygons
  #group.line.width = 1, 
  #group.point.size = 3,
  #group.colours = "#00AFBB",
  #group.colours = "#FF6666",
  group.colours = "#9900FF",
  # Background and grid lines
  #background.circle.colour = "white",
  gridline.mid.colour = "grey"
)

# single group radar graph for 6 secondary motivations
# ----------------------------------------------------
# create a new dataframe
data_motivations6 <- data %>%
  #select all motivation columns, which contain "mot_"
  select(
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) %>%
  #count the number of occurrences  
  count(motivations) %>%
  #calculate percentages
  mutate(
   perc = round(n/sum(n) * 100, 0)) %>%
  #remove n column
  select(-n) %>%
  #pivot or "spread" the motivations column for the spider graph to work
  spread(
    key = motivations,
    value = perc) %>%
  #calculate means of 2 columns to create column of secondary motivations
  rowwise() %>% 
  mutate(Social = mean(c_across(c("Competition", "Community")), na.rm = TRUE)) %>%
  mutate(Action = mean(c_across(c("Excitement", "Destruction")), na.rm = TRUE)) %>%
  mutate(Immersion = mean(c_across(c("Fantasy", "Story")), na.rm = TRUE)) %>%
  mutate(Creativity = mean(c_across(c("Discovery", "Design")), na.rm = TRUE)) %>%
  mutate(Achievement = mean(c_across(c("Completion", "Power")), na.rm = TRUE)) %>%
  mutate(Mastery = mean(c_across(c("Challenge", "Strategy")), na.rm = TRUE)) %>%
  #reorder the motivations to match the QF graph
  select(
    Social,
    Mastery,
    Achievement,
    Creativity,
    Immersion,
    Action) %>%
  #add extra column otherwise ggradar will take the first column as the group
  mutate(col = "1") %>% 
  #move the extra column to column position 1
  select(col, everything()) 
  
# plot radar graph
ggradar( 
  data_motivations6,
  # add in a fill into the graph
  fill = TRUE,
  fill.alpha = 0.5,
  # add in labels to the graph - check data above and adjust percentages as needed
  values.radar = c("0", "10", "20"),
  # plot the min, mid and max ranges (same as the labels)
  grid.min = 0,
  grid.mid = 10,
  grid.max = 20,
  # Change the polygons
  #group.line.width = 1, 
  #group.point.size = 3,
  #group.colours = "#00AFBB",
  #group.colours = "#FF6666",
  group.colours = "#9900FF",
  # Background and grid lines
  #background.circle.colour = "white",
  gridline.mid.colour = "grey"
)

```

Example 2 - plot for multiple groups - WIP
------------------------------------
```{r}
# multiple groups radar graph for 12 primary motivations
# ------------------------------------------------------
# create a new dataframe
data_motivations12_gender <- data %>%
  #select gender and all motivation columns, which contain "mot_"
  select(
    gender,
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any redundant values, e.g. "Prefer not to answer"
  filter(gender != "Prefer not to answer") %>%
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(gender != "") %>%
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) %>%
  #count the number of occurrences by gender
  group_by(gender) %>%
  count(motivations) %>%
  #calculate percentages
  mutate(
   perc = round(n/sum(n) * 100, 0)) %>%
  #remove n column
  select(-n) %>%
  #pivot or "spread" the motivations column for the spider graph to work
  spread(
    key = motivations,
    value = perc) %>%
  #replace any NAs with 0
  replace(is.na(.), 0) %>%
  #reorder the motivations to match the QF graph
  select(Competition, 
         Community,
         Challenge,
         Strategy,
         Completion,
         Power,
         Design,
         Discovery,
         Story,
         Fantasy,
         Destruction,
         Excitement) 

# specify colours to use for gender - more info on colours can be found here: http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
lcols <- c("#EEA236", "#5CB85C", "#46B8DA")

# plot radar graph
ggradar( 
  data_motivations12_gender,
  # add in a fill into the graph
  fill = TRUE,
  fill.alpha = 0.5,
  # add in labels to the graph - check data above and adjust percentages as needed
  values.radar = c("0", "15", "30"),
  # plot the min, mid and max ranges (same as the labels)
  grid.min = 0,
  grid.mid = 15,
  grid.max = 30,
  # Change the polygons
  #group.line.width = 1, 
  #group.point.size = 3,
  group.colours = lcols,
  # Background and grid lines
  #background.circle.colour = "white",
  gridline.mid.colour = "grey"
)

# multiple groups radar graph for 6 secondary motivations
# -------------------------------------------------------
# create a new dataframe
data_motivations6_gender <- data %>%
  #select gender and all motivation columns, which contain "mot_"
  select(
    gender,
    contains("mot_")) %>%
  #pivot the columns and rename the column to "mot_col"
  pivot_longer(contains("mot_"), names_to = "mot_col") %>% 
  #remove any redundant values, e.g. "Prefer not to answer"
  filter(gender != "Prefer not to answer") %>%
  #remove any NAs
  filter(!is.na(value)) %>%
  #remove any blanks
  filter(gender != "") %>%
  filter(value != "") %>%
  #remove the redundant extra "mot_col" so we're just left with the motivation values
  select(-mot_col) %>%
  #rename the motivations column "motivations" (previously called "value")
  rename(
    "motivations" = value) %>%
  #count the number of occurrences by gender
  group_by(gender) %>%
  count(motivations) %>%
  #calculate percentages
  mutate(
   perc = round(n/sum(n) * 100, 0)) %>%
  #remove n column
  select(-n) %>%
  #pivot or "spread" the motivations column for the spider graph to work
  spread(
    key = motivations,
    value = perc) %>%
  #replace any NAs with 0
  replace(is.na(.), 0) %>%
  #calculate means of 2 columns to create column of secondary motivations
  rowwise() %>% 
  mutate(Social = mean(c_across(c("Competition", "Community")), na.rm = TRUE)) %>%
  mutate(Action = mean(c_across(c("Excitement", "Destruction")), na.rm = TRUE)) %>%
  mutate(Immersion = mean(c_across(c("Fantasy", "Story")), na.rm = TRUE)) %>%
  mutate(Creativity = mean(c_across(c("Discovery", "Design")), na.rm = TRUE)) %>%
  mutate(Achievement = mean(c_across(c("Completion", "Power")), na.rm = TRUE)) %>%
  mutate(Mastery = mean(c_across(c("Challenge", "Strategy")), na.rm = TRUE)) %>%
  #reorder the motivations to match the QF graph
  select(
    Social,
    Mastery,
    Achievement,
    Creativity,
    Immersion,
    Action) 

# specify colours to use for gender - more info on colours can be found here: http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
lcols <- c("#EEA236", "#5CB85C", "#46B8DA")

# plot radar graph
ggradar( 
  data_motivations6_gender,
  # add in a fill into the graph
  fill = TRUE,
  fill.alpha = 0.5,
  # add in labels to the graph - check data above and adjust percentages as needed
  values.radar = c("0", "10", "20"),
  # plot the min, mid and max ranges (same as the labels)
  grid.min = 0,
  grid.mid = 10,
  grid.max = 20,
  # Change the polygons
  #group.line.width = 1, 
  #group.point.size = 3,
  group.colours = lcols,
  # Background and grid lines
  #background.circle.colour = "white",
  gridline.mid.colour = "grey"
)

```


==========================================================================
Practice time!
==========================================================================
Using data from a previous survey for a SCQ comparing 2 groups:

1. Copy your data to the same folder
2. Load and organise your data (homework - we'll use this data for today)
3. Plot a radar graph for 1 group 
4. Plot a radar graph for multiple groups 
========================================================================== 
